{
  "openapi": "3.1.0",
  "info": {
    "title": "Substrate API",
    "version": "2024-04-11",
    "contact": {
      "email": "support@substrate.run"
    },
    "description": "Substrate API"
  },
  "servers": [
    {
      "url": "https://api.substrate.run",
      "description": "Substrate API"
    }
  ],
  "components": {
    "schemas": {
      "ErrorOut": {
        "title": "ErrorOut",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["api_error", "invalid_request_error"],
            "description": "The type of error returned."
          },
          "message": {
            "type": "string",
            "description": "A message providing more details about the error."
          }
        },
        "required": ["type", "message"]
      },
      "GenerateTextIn": {
        "title": "GenerateTextIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Input prompt."
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.4,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate."
          },
          "node": {
            "type": "string",
            "enum": ["Mistral7BInstruct"],
            "description": "Selected node.",
            "default": "Mistral7BInstruct"
          }
        },
        "required": ["prompt"]
      },
      "GenerateTextOut": {
        "title": "GenerateTextOut",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text response."
          }
        }
      },
      "GenerateJSONIn": {
        "title": "GenerateJSONIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Input prompt."
          },
          "json_schema": {
            "type": "object",
            "description": "JSON schema to guide `json_object` response.",
            "additionalProperties": true
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.4,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate."
          },
          "node": {
            "type": "string",
            "enum": ["Mistral7BInstruct"],
            "description": "Selected node.",
            "default": "Mistral7BInstruct"
          }
        },
        "required": ["prompt", "json_schema"]
      },
      "GenerateJSONOut": {
        "title": "GenerateJSONOut",
        "type": "object",
        "properties": {
          "json_object": {
            "type": "object",
            "description": "JSON response.",
            "additionalProperties": true
          }
        }
      },
      "MultiGenerateTextIn": {
        "title": "MultiGenerateTextIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Input prompt."
          },
          "num_choices": {
            "type": "integer",
            "description": "Number of choices to generate.",
            "minimum": 1,
            "default": 1
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.4,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate."
          },
          "node": {
            "type": "string",
            "enum": ["Mistral7BInstruct"],
            "description": "Selected node.",
            "default": "Mistral7BInstruct"
          }
        },
        "required": ["prompt", "num_choices"]
      },
      "MultiGenerateTextOut": {
        "title": "MultiGenerateTextOut",
        "type": "object",
        "properties": {
          "choices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GenerateTextOut"
            }
          }
        },
        "required": ["choices"]
      },
      "MultiGenerateJSONIn": {
        "title": "MultiGenerateJSONIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Input prompt."
          },
          "json_schema": {
            "type": "object",
            "description": "JSON schema to guide `json_object` response.",
            "additionalProperties": true
          },
          "num_choices": {
            "type": "integer",
            "description": "Number of choices to generate.",
            "minimum": 1,
            "default": 1
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "default": 0.4,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate."
          },
          "node": {
            "type": "string",
            "enum": ["Mistral7BInstruct"],
            "description": "Selected node.",
            "default": "Mistral7BInstruct"
          }
        },
        "required": ["prompt", "json_schema", "num_choices"]
      },
      "MultiGenerateJSONOut": {
        "title": "MultiGenerateJSONOut",
        "type": "object",
        "properties": {
          "choices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GenerateJSONOut"
            }
          }
        },
        "required": ["choices"]
      },
      "Mistral7BInstructIn": {
        "title": "Mistral7BInstructIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Input prompt."
          },
          "num_choices": {
            "type": "integer",
            "description": "Number of choices to generate."
          },
          "json_schema": {
            "type": "object",
            "description": "JSON schema to guide response.",
            "additionalProperties": true
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 1,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate."
          }
        },
        "required": ["prompt", "num_choices"]
      },
      "Mistral7BInstructChoice": {
        "title": "Mistral7BInstructChoice",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text response, if `json_schema` was not provided."
          },
          "json_object": {
            "type": "object",
            "description": "JSON response, if `json_schema` was provided.",
            "additionalProperties": true
          }
        }
      },
      "Mistral7BInstructOut": {
        "title": "Mistral7BInstructOut",
        "type": "object",
        "properties": {
          "choices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Mistral7BInstructChoice"
            }
          }
        },
        "required": ["choices"]
      },
      "GenerateTextVisionIn": {
        "title": "GenerateTextVisionIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "image_uris": {
            "description": "Image prompts.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate.",
            "default": 800
          },
          "node": {
            "type": "string",
            "enum": ["Firellava13B"],
            "description": "Selected node.",
            "default": "Firellava13B"
          }
        },
        "required": ["prompt", "image_uris"]
      },
      "GenerateTextVisionOut": {
        "title": "GenerateTextVisionOut",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text response."
          }
        },
        "required": ["text"]
      },
      "Firellava13BIn": {
        "title": "Firellava13BIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "image_uris": {
            "description": "Image prompts.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "temperature": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "description": "Sampling temperature to use. Higher values make the output more random, lower values make the output more deterministic."
          },
          "max_tokens": {
            "type": "integer",
            "description": "Maximum number of tokens to generate.",
            "default": 800
          }
        },
        "required": ["prompt", "image_uris"]
      },
      "Firellava13BOut": {
        "title": "Firellava13BOut",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text response."
          }
        },
        "required": ["text"]
      },
      "GenerateImageIn": {
        "title": "GenerateImageIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["StableDiffusionXL"],
            "description": "Selected node.",
            "default": "StableDiffusionXL"
          }
        },
        "required": ["prompt"]
      },
      "GenerateImageOut": {
        "title": "GenerateImageOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "MultiGenerateImageIn": {
        "title": "MultiGenerateImageIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["StableDiffusionXL"],
            "description": "Selected node.",
            "default": "StableDiffusionXL"
          }
        },
        "required": ["prompt", "num_images"]
      },
      "MultiGenerateImageOut": {
        "title": "MultiGenerateImageOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GenerateImageOut"
            }
          }
        },
        "required": ["outputs"]
      },
      "StableDiffusionXLIn": {
        "title": "StableDiffusionXLIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative input prompt."
          },
          "steps": {
            "type": "integer",
            "description": "Number of diffusion steps."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate.",
            "default": 1
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "height": {
            "type": "integer",
            "description": "Height of output image, in pixels."
          },
          "width": {
            "type": "integer",
            "description": "Width of output image, in pixels."
          },
          "seeds": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Seeds for deterministic generation. Default is a random seed."
          },
          "guidance_scale": {
            "type": "number",
            "format": "float",
            "description": "Higher values adhere to the text prompt more strongly, typically at the expense of image quality.",
            "minimum": 0,
            "default": 5
          }
        },
        "required": ["prompt"]
      },
      "StableDiffusionImage": {
        "title": "StableDiffusionImage",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          },
          "seed": {
            "type": "integer",
            "description": "The random noise seed used for generation."
          }
        },
        "required": ["image_uri", "seed"]
      },
      "StableDiffusionXLOut": {
        "title": "StableDiffusionXLOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StableDiffusionImage"
            }
          }
        },
        "required": ["outputs"]
      },
      "StableDiffusionXLLightningIn": {
        "title": "StableDiffusionXLLightningIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative input prompt."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate.",
            "default": 1
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "height": {
            "type": "integer",
            "description": "Height of output image, in pixels."
          },
          "width": {
            "type": "integer",
            "description": "Width of output image, in pixels."
          },
          "seeds": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Seeds for deterministic generation. Default is a random seed."
          }
        },
        "required": ["prompt"]
      },
      "StableDiffusionXLLightningOut": {
        "title": "StableDiffusionXLLightningOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StableDiffusionImage"
            }
          }
        },
        "required": ["outputs"]
      },
      "StableDiffusionXLIPAdapterIn": {
        "title": "StableDiffusionXLIPAdapterIn",
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "image_prompt_uri": {
            "type": "string",
            "description": "Image prompt."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate.",
            "default": 1
          },
          "ip_adapter_scale": {
            "type": "number",
            "format": "float",
            "description": "Controls the influence of the image prompt on the generated output.",
            "minimum": 0
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative input prompt."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "width": {
            "type": "integer",
            "description": "Width of output image, in pixels."
          },
          "height": {
            "type": "integer",
            "description": "Height of output image, in pixels."
          },
          "seeds": {
            "description": "Random noise seeds. Default is random seeds for each generation.",
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "required": ["prompt", "num_images"]
      },
      "StableDiffusionXLIPAdapterOut": {
        "title": "StableDiffusionXLIPAdapterOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StableDiffusionImage"
            }
          }
        },
        "required": ["outputs"]
      },
      "StableDiffusionXLControlNetIn": {
        "title": "StableDiffusionXLControlNetIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "control_method": {
            "type": "string",
            "enum": ["edge", "depth", "illusion"],
            "description": "Strategy to control generation using the input image."
          },
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate.",
            "default": 1
          },
          "output_resolution": {
            "type": "integer",
            "description": "Resolution of the output image, in pixels.",
            "default": 1024
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative input prompt."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "conditioning_scale": {
            "type": "number",
            "format": "float",
            "description": "Controls the influence of the input image on the generated output.",
            "minimum": 0
          },
          "seeds": {
            "description": "Random noise seeds. Default is random seeds for each generation.",
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "required": ["image_uri", "control_method", "prompt", "num_images"]
      },
      "StableDiffusionXLControlNetOut": {
        "title": "StableDiffusionXLControlNetOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StableDiffusionImage"
            }
          }
        },
        "required": ["outputs"]
      },
      "GenerativeEditImageIn": {
        "title": "GenerativeEditImageIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Original image."
          },
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "mask_image_uri": {
            "type": "string",
            "description": "Mask image that controls which pixels are inpainted. If unset, the entire image is edited (image-to-image)."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["StableDiffusionXLInpaint"],
            "description": "Selected node.",
            "default": "StableDiffusionXLInpaint"
          }
        },
        "required": ["image_uri", "prompt"]
      },
      "GenerativeEditImageOut": {
        "title": "GenerativeEditImageOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "MultiGenerativeEditImageIn": {
        "title": "MultiGenerativeEditImageIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Original image."
          },
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "mask_image_uri": {
            "type": "string",
            "description": "Mask image that controls which pixels are edited (inpainting). If unset, the entire image is edited (image-to-image)."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["StableDiffusionXLInpaint"],
            "description": "Selected node.",
            "default": "StableDiffusionXLInpaint"
          }
        },
        "required": ["image_uri", "prompt", "num_images"]
      },
      "MultiGenerativeEditImageOut": {
        "title": "MultiGenerativeEditImageOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GenerativeEditImageOut"
            }
          }
        },
        "required": ["outputs"]
      },
      "StableDiffusionXLInpaintIn": {
        "title": "StableDiffusionXLInpaintIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Original image."
          },
          "prompt": {
            "type": "string",
            "description": "Text prompt."
          },
          "mask_image_uri": {
            "type": "string",
            "description": "Mask image that controls which pixels are edited (inpainting). If unset, the entire image is edited (image-to-image)."
          },
          "num_images": {
            "type": "integer",
            "description": "Number of images to generate.",
            "default": 1
          },
          "output_resolution": {
            "type": "integer",
            "description": "Resolution of the output image, in pixels.",
            "default": 1024
          },
          "negative_prompt": {
            "type": "string",
            "description": "Negative input prompt."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "strength": {
            "type": "number",
            "format": "float",
            "description": "Controls the strength of the generation process.",
            "minimum": 0,
            "maximum": 1,
            "default": 1.0
          },
          "seeds": {
            "description": "Random noise seeds. Default is random seeds for each generation.",
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "required": ["image_uri", "prompt", "num_images"]
      },
      "StableDiffusionXLInpaintOut": {
        "title": "StableDiffusionXLInpaintOut",
        "type": "object",
        "properties": {
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StableDiffusionImage"
            }
          }
        },
        "required": ["outputs"]
      },
      "BoundingBox": {
        "title": "BoundingBox",
        "type": "object",
        "properties": {
          "x1": {
            "type": "number",
            "format": "float",
            "description": "Top left corner x."
          },
          "y1": {
            "type": "number",
            "format": "float",
            "description": "Top left corner y."
          },
          "x2": {
            "type": "number",
            "format": "float",
            "description": "Bottom right corner x."
          },
          "y2": {
            "type": "number",
            "format": "float",
            "description": "Bottom right corner y."
          }
        },
        "required": ["x1", "y1", "x2", "y2"]
      },
      "Point": {
        "title": "Point",
        "type": "object",
        "properties": {
          "x": {
            "type": "integer",
            "description": "X position."
          },
          "y": {
            "type": "integer",
            "description": "Y position."
          }
        },
        "required": ["x", "y"]
      },
      "FillMaskIn": {
        "title": "FillMaskIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "mask_image_uri": {
            "type": "string",
            "description": "Mask image that controls which pixels are inpainted."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["BigLaMa"],
            "description": "Selected node.",
            "default": "BigLaMa"
          }
        },
        "required": ["image_uri", "mask_image_uri"]
      },
      "FillMaskOut": {
        "title": "FillMaskOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "BigLaMaIn": {
        "title": "BigLaMaIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "mask_image_uri": {
            "type": "string",
            "description": "Mask image that controls which pixels are inpainted."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          }
        },
        "required": ["image_uri", "mask_image_uri"]
      },
      "BigLaMaOut": {
        "title": "BigLaMaOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "RemoveBackgroundIn": {
        "title": "RemoveBackgroundIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "return_mask": {
            "type": "boolean",
            "description": "Return a mask image instead of the original content.",
            "default": false
          },
          "background_color": {
            "type": "string",
            "description": "Hex value background color. Transparent if unset."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["DISISNet"],
            "description": "Selected node.",
            "default": "DISISNet"
          }
        },
        "required": ["image_uri"]
      },
      "RemoveBackgroundOut": {
        "title": "RemoveBackgroundOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "DISISNetIn": {
        "title": "DISISNetIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          }
        },
        "required": ["image_uri"]
      },
      "DISISNetOut": {
        "title": "DISISNetOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "UpscaleImageIn": {
        "title": "UpscaleImageIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["RealESRGAN"],
            "description": "Selected node.",
            "default": "RealESRGAN"
          }
        },
        "required": ["image_uri"]
      },
      "UpscaleImageOut": {
        "title": "UpscaleImageOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "RealESRGANIn": {
        "title": "RealESRGANIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          }
        },
        "required": ["image_uri"]
      },
      "RealESRGANOut": {
        "title": "RealESRGANOut",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["image_uri"]
      },
      "SegmentUnderPointIn": {
        "title": "SegmentUnderPointIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "point": {
            "description": "Point prompt.",
            "type": "object",
            "$ref": "#/components/schemas/Point"
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["SegmentAnything"],
            "description": "Selected node.",
            "default": "SegmentAnything"
          }
        },
        "required": ["image_uri", "point"]
      },
      "SegmentUnderPointOut": {
        "title": "SegmentUnderPointOut",
        "type": "object",
        "properties": {
          "mask_image_uri": {
            "type": "string",
            "description": "Detected segments in 'mask image' format. Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["mask_image_uri"]
      },
      "SegmentAnythingIn": {
        "title": "SegmentAnythingIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Input image."
          },
          "point_prompts": {
            "description": "Point prompts, to detect a segment under the point. One of `point_prompts` or `box_prompts` must be set.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Point"
            }
          },
          "box_prompts": {
            "description": "Box prompts, to detect a segment within the bounding box. One of `point_prompts` or `box_prompts` must be set.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBox"
            }
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an image URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the image data will be returned as a base64-encoded string."
          }
        },
        "required": ["image_uri"]
      },
      "SegmentAnythingOut": {
        "title": "SegmentAnythingOut",
        "type": "object",
        "properties": {
          "mask_image_uri": {
            "type": "string",
            "description": "Detected segments in 'mask image' format. Base 64-encoded JPEG image bytes, or a hosted image url if `store` is provided."
          }
        },
        "required": ["mask_image_uri"]
      },
      "TranscribeMediaIn": {
        "title": "TranscribeMediaIn",
        "type": "object",
        "properties": {
          "audio_uri": {
            "type": "string",
            "description": "Input audio."
          },
          "prompt": {
            "type": "string",
            "description": "Prompt to guide model on the content and context of input audio."
          },
          "language": {
            "type": "string",
            "default": "en",
            "description": "Language of input audio in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes) format."
          },
          "segment": {
            "type": "boolean",
            "default": false,
            "description": "Segment the text into sentences with approximate timestamps."
          },
          "align": {
            "type": "boolean",
            "default": false,
            "description": "Align transcription to produce more accurate sentence-level timestamps and word-level timestamps. An array of word segments will be included in each sentence segment."
          },
          "diarize": {
            "type": "boolean",
            "default": false,
            "description": "Identify speakers for each segment. Speaker IDs will be included in each segment."
          },
          "suggest_chapters": {
            "type": "boolean",
            "default": false,
            "description": "Suggest automatic chapter markers."
          }
        },
        "required": ["audio_uri"]
      },
      "TranscribedWord": {
        "title": "TranscribedWord",
        "type": "object",
        "properties": {
          "word": {
            "type": "string",
            "description": "Text of word."
          },
          "start": {
            "type": "number",
            "format": "float",
            "description": "Start time of word, in seconds."
          },
          "end": {
            "type": "number",
            "format": "float",
            "description": "End time of word, in seconds."
          },
          "speaker": {
            "type": "string",
            "description": "ID of speaker, if `diarize` is enabled."
          }
        },
        "required": ["word"]
      },
      "TranscribedSegment": {
        "title": "TranscribedSegment",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text of segment."
          },
          "start": {
            "type": "number",
            "format": "float",
            "description": "Start time of segment, in seconds."
          },
          "end": {
            "type": "number",
            "format": "float",
            "description": "End time of segment, in seconds."
          },
          "speaker": {
            "type": "string",
            "description": "ID of speaker, if `diarize` is enabled."
          },
          "words": {
            "type": "array",
            "description": "Aligned words, if `align` is enabled.",
            "items": {
              "$ref": "#/components/schemas/TranscribedWord"
            }
          }
        },
        "required": ["text", "start", "end"]
      },
      "ChapterMarker": {
        "title": "ChapterMarker",
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Chapter title."
          },
          "start": {
            "type": "number",
            "format": "float",
            "description": "Start time of chapter, in seconds."
          }
        },
        "required": ["title", "start"]
      },
      "TranscribeMediaOut": {
        "title": "TranscribeMediaOut",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Transcribed text."
          },
          "segments": {
            "type": "array",
            "description": "Transcribed segments, if `segment` is enabled.",
            "items": {
              "$ref": "#/components/schemas/TranscribedSegment"
            }
          },
          "chapters": {
            "type": "array",
            "description": "Chapter markers, if `suggest_chapters` is enabled.",
            "items": {
              "$ref": "#/components/schemas/ChapterMarker"
            }
          }
        },
        "required": ["text"]
      },
      "GenerateSpeechIn": {
        "title": "GenerateSpeechIn",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Input text."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an audio URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the audio data will be returned as a base64-encoded string."
          },
          "node": {
            "type": "string",
            "enum": ["XTTSV2"],
            "description": "Selected node.",
            "default": "XTTSV2"
          }
        },
        "required": ["text"]
      },
      "GenerateSpeechOut": {
        "title": "GenerateSpeechOut",
        "type": "object",
        "properties": {
          "audio_uri": {
            "type": "string",
            "description": "Base 64-encoded WAV audio bytes, or a hosted audio url if `store` is provided."
          }
        },
        "required": ["audio_uri"]
      },
      "XTTSV2In": {
        "title": "XTTSV2In",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Input text."
          },
          "audio_uri": {
            "type": "string",
            "description": "Reference audio used to synthesize the speaker. If unset, a default speaker voice will be used."
          },
          "language": {
            "type": "string",
            "default": "en",
            "description": "Language of input text. Supported languages: `en, de, fr, es, it, pt, pl, zh, ar, cs, ru, nl, tr, hu, ko`."
          },
          "store": {
            "type": "string",
            "description": "Use \"hosted\" to return an audio URL hosted on Substrate. You can also provide a URL to a registered [file store](/docs/file-stores). If unset, the audio data will be returned as a base64-encoded string."
          }
        },
        "required": ["text"]
      },
      "XTTSV2Out": {
        "title": "XTTSV2Out",
        "type": "object",
        "properties": {
          "audio_uri": {
            "type": "string",
            "description": "Base 64-encoded WAV audio bytes, or a hosted audio url if `store` is provided."
          }
        },
        "required": ["audio_uri"]
      },
      "Embedding": {
        "title": "Embedding",
        "type": "object",
        "properties": {
          "vector": {
            "type": "array",
            "description": "Embedding vector.",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID."
          },
          "metadata": {
            "type": "object",
            "description": "Vector store document metadata.",
            "additionalProperties": true
          }
        },
        "required": ["vector"]
      },
      "EmbedTextIn": {
        "title": "EmbedTextIn",
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text to embed."
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata that can be used to query the vector store. Ignored if `store` is unset.",
            "additionalProperties": true
          },
          "embedded_metadata_keys": {
            "type": "array",
            "description": "Choose keys from `metadata` to embed with text.",
            "items": {
              "type": "string"
            }
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID. Ignored if `store` is unset."
          },
          "node": {
            "type": "string",
            "enum": ["JinaV2", "CLIP"],
            "description": "Selected node.",
            "default": "JinaV2"
          }
        },
        "required": ["text"]
      },
      "EmbedTextOut": {
        "title": "EmbedTextOut",
        "type": "object",
        "properties": {
          "embedding": {
            "type": "object",
            "description": "Generated embedding.",
            "$ref": "#/components/schemas/Embedding"
          }
        },
        "required": ["embedding"]
      },
      "EmbedTextItem": {
        "type": "object",
        "title": "EmbedTextItem",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text to embed."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata that can be used to query the vector store. Ignored if `store` is unset.",
            "additionalProperties": true
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID. Ignored if `store` is unset."
          }
        },
        "required": ["text"]
      },
      "MultiEmbedTextIn": {
        "title": "MultiEmbedTextIn",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "description": "Items to embed.",
            "items": {
              "$ref": "#/components/schemas/EmbedTextItem"
            }
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          },
          "embedded_metadata_keys": {
            "type": "array",
            "description": "Choose keys from `metadata` to embed with text.",
            "items": {
              "type": "string"
            }
          },
          "node": {
            "type": "string",
            "enum": ["JinaV2", "CLIP"],
            "description": "Selected node.",
            "default": "JinaV2"
          }
        },
        "required": ["items"]
      },
      "MultiEmbedTextOut": {
        "title": "MultiEmbedTextOut",
        "type": "object",
        "properties": {
          "embeddings": {
            "type": "array",
            "description": "Generated embeddings.",
            "items": {
              "$ref": "#/components/schemas/Embedding"
            }
          }
        },
        "required": ["embeddings"]
      },
      "JinaV2In": {
        "title": "JinaV2In",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "description": "Items to embed.",
            "items": {
              "$ref": "#/components/schemas/EmbedTextItem"
            }
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          },
          "embedded_metadata_keys": {
            "type": "array",
            "description": "Choose keys from `metadata` to embed with text.",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["items"]
      },
      "JinaV2Out": {
        "title": "JinaV2Out",
        "type": "object",
        "properties": {
          "embeddings": {
            "type": "array",
            "description": "Generated embeddings.",
            "items": {
              "$ref": "#/components/schemas/Embedding"
            }
          }
        },
        "required": ["embeddings"]
      },
      "EmbedImageIn": {
        "title": "EmbedImageIn",
        "type": "object",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Image to embed."
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID. Ignored if `store` is unset."
          },
          "node": {
            "type": "string",
            "enum": ["CLIP"],
            "description": "Selected node.",
            "default": "CLIP"
          }
        },
        "required": ["image_uri"]
      },
      "EmbedImageOut": {
        "title": "EmbedImageOut",
        "type": "object",
        "properties": {
          "embedding": {
            "type": "object",
            "description": "Generated embedding.",
            "$ref": "#/components/schemas/Embedding"
          }
        },
        "required": ["embedding"]
      },
      "EmbedImageItem": {
        "type": "object",
        "title": "EmbedImageItem",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Image to embed."
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID. Ignored if `store` is unset."
          }
        },
        "required": ["image_uri"]
      },
      "EmbedTextOrImageItem": {
        "type": "object",
        "title": "EmbedTextOrImageItem",
        "properties": {
          "image_uri": {
            "type": "string",
            "description": "Image to embed."
          },
          "text": {
            "type": "string",
            "description": "Text to embed."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata that can be used to query the vector store. Ignored if `store` is unset.",
            "additionalProperties": true
          },
          "doc_id": {
            "type": "string",
            "description": "Vector store document ID. Ignored if `store` is unset."
          }
        },
        "required": []
      },
      "MultiEmbedImageIn": {
        "title": "MultiEmbedImageIn",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "description": "Items to embed.",
            "items": {
              "$ref": "#/components/schemas/EmbedImageItem"
            }
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          },
          "node": {
            "type": "string",
            "enum": ["CLIP"],
            "description": "Selected node.",
            "default": "CLIP"
          }
        },
        "required": ["items"]
      },
      "MultiEmbedImageOut": {
        "title": "MultiEmbedImageOut",
        "type": "object",
        "properties": {
          "embeddings": {
            "type": "array",
            "description": "Generated embeddings.",
            "items": {
              "$ref": "#/components/schemas/Embedding"
            }
          }
        },
        "required": ["embeddings"]
      },
      "CLIPIn": {
        "title": "CLIPIn",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "description": "Items to embed.",
            "items": {
              "$ref": "#/components/schemas/EmbedTextOrImageItem"
            }
          },
          "embedded_metadata_keys": {
            "type": "array",
            "description": "Choose keys from `metadata` to embed with text, when embedding and storing text documents.",
            "items": {
              "type": "string"
            }
          },
          "store": {
            "type": "string",
            "description": "[Vector store](/docs/vector-stores) identifier."
          }
        },
        "required": ["items"]
      },
      "CLIPOut": {
        "title": "CLIPOut",
        "type": "object",
        "properties": {
          "embeddings": {
            "type": "array",
            "description": "Generated embeddings.",
            "items": {
              "$ref": "#/components/schemas/Embedding"
            }
          }
        },
        "required": ["embeddings"]
      },
      "CreateVectorStoreIn": {
        "title": "CreateVectorStoreIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name.",
            "minLength": 1,
            "maxLength": 63
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "m": {
            "type": "integer",
            "minimum": 1,
            "maximum": 64,
            "default": 16,
            "description": "The max number of connections per layer for the index."
          },
          "ef_construction": {
            "type": "integer",
            "minimum": 1,
            "maximum": 128,
            "description": "The size of the dynamic candidate list for constructing the index graph.",
            "default": 64
          },
          "metric": {
            "type": "string",
            "enum": ["cosine", "l2", "inner"],
            "default": "inner",
            "description": "The distance metric to construct the index with."
          }
        },
        "required": ["name", "model"]
      },
      "CreateVectorStoreOut": {
        "title": "CreateVectorStoreOut",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name.",
            "minLength": 1,
            "maxLength": 63
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "m": {
            "type": "integer",
            "minimum": 1,
            "maximum": 64,
            "default": 16,
            "description": "The max number of connections per layer for the index."
          },
          "ef_construction": {
            "type": "integer",
            "minimum": 1,
            "maximum": 128,
            "description": "The size of the dynamic candidate list for constructing the index graph.",
            "default": 64
          },
          "metric": {
            "type": "string",
            "enum": ["cosine", "l2", "inner"],
            "default": "inner",
            "description": "The distance metric to construct the index with."
          }
        },
        "required": ["name", "model", "m", "ef_construction", "metric"]
      },
      "ListVectorStoresIn": {
        "title": "ListVectorStoresIn",
        "type": "object",
        "properties": {}
      },
      "ListVectorStoresOut": {
        "title": "ListVectorStoresOut",
        "type": "object",
        "properties": {
          "stores": {
            "type": "array",
            "description": "List of vector stores.",
            "items": {
              "$ref": "#/components/schemas/CreateVectorStoreOut"
            }
          }
        }
      },
      "DeleteVectorStoreIn": {
        "title": "DeleteVectorStoreIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          }
        },
        "required": ["name", "model"]
      },
      "DeleteVectorStoreOut": {
        "title": "DeleteVectorStoreOut",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          }
        },
        "required": ["name", "model"]
      },
      "Vector": {
        "title": "Vector",
        "type": "object",
        "description": "Canonical representation of document with embedding vector.",
        "properties": {
          "id": {
            "type": "string",
            "description": "Document ID."
          },
          "vector": {
            "type": "array",
            "description": "Embedding vector.",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Document metadata.",
            "additionalProperties": true
          }
        },
        "required": ["id", "vector", "metadata"]
      },
      "FetchVectorsIn": {
        "title": "FetchVectorsIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "ids": {
            "type": "array",
            "description": "Document IDs to retrieve.",
            "items": {
              "type": "string"
            },
            "maxItems": 100
          }
        },
        "required": ["name", "model", "ids"]
      },
      "FetchVectorsOut": {
        "title": "FetchVectorsOut",
        "type": "object",
        "properties": {
          "vectors": {
            "type": "array",
            "description": "Retrieved vectors.",
            "items": {
              "$ref": "#/components/schemas/Vector"
            }
          }
        },
        "required": ["vectors"]
      },
      "UpdateVectorsOut": {
        "title": "UpdateVectorsOut",
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of vectors modified."
          }
        },
        "required": ["count"]
      },
      "DeleteVectorsOut": {
        "title": "DeleteVectorsOut",
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of vectors modified."
          }
        },
        "required": ["count"]
      },
      "UpdateVectorParams": {
        "title": "UpdateVectorParams",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Document ID."
          },
          "vector": {
            "type": "array",
            "description": "Embedding vector.",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Document metadata.",
            "additionalProperties": true
          }
        },
        "required": ["id"]
      },
      "UpdateVectorsIn": {
        "title": "UpdateVectorsIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "vectors": {
            "type": "array",
            "description": "Vectors to upsert.",
            "items": {
              "$ref": "#/components/schemas/UpdateVectorParams"
            },
            "maxItems": 100
          }
        },
        "required": ["name", "model", "vectors"]
      },
      "DeleteVectorsIn": {
        "title": "DeleteVectorsIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "ids": {
            "type": "array",
            "description": "Document IDs to delete.",
            "items": {
              "type": "string"
            },
            "maxItems": 100
          }
        },
        "required": ["name", "model", "ids"]
      },
      "QueryVectorStoreIn": {
        "title": "QueryVectorStoreIn",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Vector store to query against."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "query_ids": {
            "type": "array",
            "description": "Document IDs to use for the query.",
            "items": {
              "type": "string"
            }
          },
          "query_image_uris": {
            "type": "array",
            "description": "Image URIs to embed and use for the query.",
            "items": {
              "type": "string"
            }
          },
          "query_vectors": {
            "type": "array",
            "description": "Vector to use for the query.",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            }
          },
          "query_strings": {
            "type": "array",
            "description": "Texts to embed and use for the query.",
            "items": {
              "type": "string"
            }
          },
          "top_k": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "default": 10,
            "description": "Number of results to return."
          },
          "ef_search": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "default": 40,
            "description": "The size of the dynamic candidate list for searching the index graph."
          },
          "include_values": {
            "type": "boolean",
            "default": false,
            "description": "Include the values of the vectors in the response."
          },
          "include_metadata": {
            "type": "boolean",
            "default": false,
            "description": "Include the metadata of the vectors in the response."
          },
          "filters": {
            "type": "object",
            "description": "Filter metadata by key-value pairs.",
            "additionalProperties": true
          },
          "metric": {
            "type": "string",
            "enum": ["cosine", "l2", "inner"],
            "description": "The distance metric used for the query. Defaults to the distance metric the vector store was created with."
          }
        },
        "required": ["name", "model"]
      },
      "VectorStoreQueryResult": {
        "title": "VectorStoreQueryResult",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Document ID."
          },
          "distance": {
            "type": "number",
            "format": "float",
            "description": "Similarity score."
          },
          "vector": {
            "type": "array",
            "description": "Embedding vector.",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Document metadata.",
            "additionalProperties": true
          }
        },
        "required": ["id", "distance"]
      },
      "QueryVectorStoreOut": {
        "title": "QueryVectorStoreOut",
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "Query results.",
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/VectorStoreQueryResult"
              }
            }
          },
          "name": {
            "type": "string",
            "description": "Vector store name."
          },
          "model": {
            "type": "string",
            "description": "Selected embedding model",
            "enum": ["jina-v2", "clip"]
          },
          "metric": {
            "type": "string",
            "enum": ["cosine", "l2", "inner"],
            "description": "The distance metric used for the query."
          }
        },
        "required": ["results"]
      }
    }
  },
  "paths": {
    "/GenerateText": {
      "post": {
        "summary": "GenerateText",
        "operationId": "GenerateText",
        "tags": ["language-generation"],
        "description": "Generate text using a language model.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerateTextIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateTextOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiGenerateText": {
      "post": {
        "summary": "MultiGenerateText",
        "operationId": "MultiGenerateText",
        "tags": ["language-generation"],
        "description": "Generate multiple text choices using a language model.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiGenerateTextIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiGenerateTextOut"
                }
              }
            }
          }
        }
      }
    },
    "/GenerateJSON": {
      "post": {
        "summary": "GenerateJSON",
        "operationId": "GenerateJSON",
        "tags": ["language-generation"],
        "description": "Generate JSON using a language model.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerateJSONIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateJSONOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiGenerateJSON": {
      "post": {
        "summary": "MultiGenerateJSON",
        "operationId": "MultiGenerateJSON",
        "tags": ["language-generation"],
        "description": "Generate multiple JSON choices using a language model.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiGenerateJSONIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiGenerateJSONOut"
                }
              }
            }
          }
        }
      }
    },
    "/GenerateTextVision": {
      "post": {
        "summary": "GenerateTextVision",
        "operationId": "GenerateTextVision",
        "tags": ["language-generation"],
        "description": "Generate text with image input.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerateTextVisionIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateTextVisionOut"
                }
              }
            }
          }
        }
      }
    },
    "/Mistral7BInstruct": {
      "post": {
        "summary": "Mistral7BInstruct",
        "operationId": "Mistral7BInstruct",
        "tags": ["language-generation", "low"],
        "description": "Generate text using [Mistral 7B Instruct](https://mistral.ai/news/announcing-mistral-7b).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Mistral7BInstructIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Mistral7BInstructOut"
                }
              }
            }
          }
        }
      }
    },
    "/Firellava13B": {
      "post": {
        "summary": "Firellava13B",
        "operationId": "Firellava13B",
        "tags": ["language-generation", "low"],
        "description": "Generate text with image input using [FireLLaVA 13B](https://fireworks.ai/blog/firellava-the-first-commercially-permissive-oss-llava-model).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/Firellava13BIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Firellava13BOut"
                }
              }
            }
          }
        }
      }
    },
    "/GenerateImage": {
      "post": {
        "summary": "GenerateImage",
        "operationId": "GenerateImage",
        "tags": ["image-generation"],
        "description": "Generate an image.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerateImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiGenerateImage": {
      "post": {
        "summary": "MultiGenerateImage",
        "operationId": "MultiGenerateImage",
        "tags": ["image-generation"],
        "description": "Generate multiple images.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiGenerateImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiGenerateImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/GenerativeEditImage": {
      "post": {
        "summary": "GenerativeEditImage",
        "operationId": "GenerativeEditImage",
        "tags": ["image-generation"],
        "description": "Edit an image using image generation.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerativeEditImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerativeEditImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiGenerativeEditImage": {
      "post": {
        "summary": "MultiGenerativeEditImage",
        "operationId": "MultiGenerativeEditImage",
        "tags": ["image-generation"],
        "description": "Edit multiple images using image generation.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiGenerativeEditImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiGenerativeEditImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/StableDiffusionXL": {
      "post": {
        "summary": "StableDiffusionXL",
        "operationId": "StableDiffusionXL",
        "tags": ["image-generation", "low"],
        "description": "Generate an image using [Stable Diffusion XL](https://arxiv.org/abs/2307.01952).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/StableDiffusionXLIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StableDiffusionXLOut"
                }
              }
            }
          }
        }
      }
    },
    "/StableDiffusionXLLightning": {
      "post": {
        "summary": "StableDiffusionXLLightning",
        "operationId": "StableDiffusionXLLightning",
        "tags": ["image-generation", "low"],
        "description": "Generate an image using [Stable Diffusion XL Lightning](https://arxiv.org/abs/2402.13929).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/StableDiffusionXLLightningIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StableDiffusionXLLightningOut"
                }
              }
            }
          }
        }
      }
    },
    "/StableDiffusionXLInpaint": {
      "post": {
        "summary": "StableDiffusionXLInpaint",
        "operationId": "StableDiffusionXLInpaint",
        "tags": ["image-generation", "low"],
        "description": "Edit an image using [Stable Diffusion XL](https://arxiv.org/abs/2307.01952). Supports inpainting (edit part of the image with a mask) and image-to-image (edit the full image).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/StableDiffusionXLInpaintIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StableDiffusionXLInpaintOut"
                }
              }
            }
          }
        }
      }
    },
    "/StableDiffusionXLIPAdapter": {
      "post": {
        "summary": "StableDiffusionXLIPAdapter",
        "operationId": "StableDiffusionXLIPAdapter",
        "tags": ["image-generation", "low"],
        "description": "Generate an image with an image prompt, using Stable Diffusion XL with [IP-Adapter](https://arxiv.org/abs/2308.06721).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/StableDiffusionXLIPAdapterIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StableDiffusionXLIPAdapterOut"
                }
              }
            }
          }
        }
      }
    },
    "/StableDiffusionXLControlNet": {
      "post": {
        "summary": "StableDiffusionXLControlNet",
        "operationId": "StableDiffusionXLControlNet",
        "tags": ["image-generation", "low"],
        "description": "Generate an image with generation structured by an input image, using Stable Diffusion XL with [ControlNet](https://arxiv.org/abs/2302.05543).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/StableDiffusionXLControlNetIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StableDiffusionXLControlNetOut"
                }
              }
            }
          }
        }
      }
    },
    "/FillMask": {
      "post": {
        "summary": "FillMask",
        "operationId": "FillMask",
        "tags": ["image-utility"],
        "description": "Fill (inpaint) part of an image, e.g. to 'remove' an object.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/FillMaskIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FillMaskOut"
                }
              }
            }
          }
        }
      }
    },
    "/BigLaMa": {
      "post": {
        "summary": "BigLaMa",
        "operationId": "BigLaMa",
        "tags": ["image-utility", "low"],
        "description": "Inpaint a mask using [LaMa](https://github.com/advimman/lama).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/BigLaMaIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BigLaMaOut"
                }
              }
            }
          }
        }
      }
    },
    "/UpscaleImage": {
      "post": {
        "summary": "UpscaleImage",
        "operationId": "UpscaleImage",
        "tags": ["image-utility"],
        "description": "Upscale an image.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/UpscaleImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpscaleImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/RealESRGAN": {
      "post": {
        "summary": "RealESRGAN",
        "operationId": "RealESRGAN",
        "tags": ["image-utility", "low"],
        "description": "Upscale an image using [RealESRGAN](https://github.com/xinntao/Real-ESRGAN).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/RealESRGANIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RealESRGANOut"
                }
              }
            }
          }
        }
      }
    },
    "/RemoveBackground": {
      "post": {
        "summary": "RemoveBackground",
        "operationId": "RemoveBackground",
        "tags": ["image-utility"],
        "description": "Remove the background from an image, with the option to return the foreground as a mask.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/RemoveBackgroundIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveBackgroundOut"
                }
              }
            }
          }
        }
      }
    },
    "/DISISNet": {
      "post": {
        "summary": "DISISNet",
        "operationId": "DISISNet",
        "tags": ["image-utility", "low"],
        "description": "Segment image foreground using [DIS IS-Net](https://github.com/xuebinqin/DIS).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/DISISNetIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DISISNetOut"
                }
              }
            }
          }
        }
      }
    },
    "/SegmentUnderPoint": {
      "post": {
        "summary": "SegmentUnderPoint",
        "operationId": "SegmentUnderPoint",
        "tags": ["image-utility"],
        "description": "Segment an image under a point and return the segment.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/SegmentUnderPointIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentUnderPointOut"
                }
              }
            }
          }
        }
      }
    },
    "/SegmentAnything": {
      "post": {
        "summary": "SegmentAnything",
        "operationId": "SegmentAnything",
        "tags": ["image-utility", "low"],
        "description": "Segment an image using [SegmentAnything](https://github.com/facebookresearch/segment-anything).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/SegmentAnythingIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentAnythingOut"
                }
              }
            }
          }
        }
      }
    },
    "/TranscribeMedia": {
      "post": {
        "summary": "TranscribeMedia",
        "operationId": "TranscribeMedia",
        "tags": ["audio"],
        "description": "Transcribe speech in an audio or video file.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/TranscribeMediaIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeMediaOut"
                }
              }
            }
          }
        }
      }
    },
    "/GenerateSpeech": {
      "post": {
        "summary": "GenerateSpeech",
        "operationId": "GenerateSpeech",
        "tags": ["audio"],
        "description": "Generate speech from text.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/GenerateSpeechIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateSpeechOut"
                }
              }
            }
          }
        }
      }
    },
    "/XTTSV2": {
      "post": {
        "summary": "XTTSV2",
        "operationId": "XTTSV2",
        "tags": ["audio", "low"],
        "description": "Generate speech from text using [XTTS v2](https://docs.coqui.ai/en/latest/models/xtts.html).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/XTTSV2In"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/XTTSV2Out"
                }
              }
            }
          }
        }
      }
    },
    "/EmbedText": {
      "post": {
        "summary": "EmbedText",
        "operationId": "EmbedText",
        "tags": ["embedding"],
        "description": "Generate embedding for a text document.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/EmbedTextIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbedTextOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiEmbedText": {
      "post": {
        "summary": "MultiEmbedText",
        "operationId": "MultiEmbedText",
        "tags": ["embedding"],
        "description": "Generate embeddings for multiple text documents.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiEmbedTextIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiEmbedTextOut"
                }
              }
            }
          }
        }
      }
    },
    "/EmbedImage": {
      "post": {
        "summary": "EmbedImage",
        "operationId": "EmbedImage",
        "tags": ["embedding"],
        "description": "Generate embedding for an image.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/EmbedImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbedImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/MultiEmbedImage": {
      "post": {
        "summary": "MultiEmbedImage",
        "operationId": "MultiEmbedImage",
        "tags": ["embedding"],
        "description": "Generate embeddings for multiple images.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/MultiEmbedImageIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiEmbedImageOut"
                }
              }
            }
          }
        }
      }
    },
    "/JinaV2": {
      "post": {
        "summary": "JinaV2",
        "operationId": "JinaV2",
        "tags": ["embedding", "low"],
        "description": "Generate embeddings for multiple text documents using [Jina Embeddings 2](https://arxiv.org/abs/2310.19923).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/JinaV2In"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JinaV2Out"
                }
              }
            }
          }
        }
      }
    },
    "/CLIP": {
      "post": {
        "summary": "CLIP",
        "operationId": "CLIP",
        "tags": ["embedding", "low"],
        "description": "Generate embeddings for text or images using [CLIP](https://openai.com/research/clip).",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/CLIPIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CLIPOut"
                }
              }
            }
          }
        }
      }
    },
    "/CreateVectorStore": {
      "post": {
        "tags": ["vector-store"],
        "summary": "CreateVectorStore",
        "operationId": "CreateVectorStore",
        "description": "Create a vector store for storing and querying embeddings.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/CreateVectorStoreIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Vector store created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateVectorStoreOut"
                }
              }
            }
          }
        }
      }
    },
    "/ListVectorStores": {
      "post": {
        "tags": ["vector-store"],
        "summary": "ListVectorStores",
        "operationId": "ListVectorStores",
        "description": "List all vector stores.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/ListVectorStoresIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of vector stores.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVectorStoresOut"
                }
              }
            }
          }
        }
      }
    },
    "/DeleteVectorStore": {
      "post": {
        "tags": ["vector-store"],
        "summary": "DeleteVectorStore",
        "operationId": "DeleteVectorStore",
        "description": "Delete a vector store.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/DeleteVectorStoreIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteVectorStoreOut"
                }
              }
            }
          }
        }
      }
    },
    "/QueryVectorStore": {
      "post": {
        "tags": ["vector-store"],
        "summary": "QueryVectorStore",
        "operationId": "QueryVectorStore",
        "description": "Query a vector store for similar vectors.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/QueryVectorStoreIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Query results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryVectorStoreOut"
                }
              }
            }
          }
        }
      }
    },
    "/FetchVectors": {
      "post": {
        "tags": ["vector-store"],
        "summary": "FetchVectors",
        "operationId": "FetchVectors",
        "description": "Fetch vectors from a vector store.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/FetchVectorsIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Vector data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchVectorsOut"
                }
              }
            }
          }
        }
      }
    },
    "/UpdateVectors": {
      "post": {
        "tags": ["vector-store"],
        "summary": "UpdateVectors",
        "operationId": "UpdateVectors",
        "description": "Update vectors in a vector store.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/UpdateVectorsIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Count of updated vectors.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateVectorsOut"
                }
              }
            }
          }
        }
      }
    },
    "/DeleteVectors": {
      "post": {
        "tags": ["vector-store"],
        "summary": "DeleteVectors",
        "operationId": "DeleteVectors",
        "description": "Delete vectors in a vector store.",
        "parameters": [
          {
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/DeleteVectorsIn"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Count of deleted vectors.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteVectorsOut"
                }
              }
            }
          }
        }
      }
    }
  },
  "tags": [
    {
      "name": "language-generation",
      "description": "Language Generation Nodes"
    },
    {
      "name": "image-generation",
      "description": "Image Generation Nodes"
    },
    {
      "name": "image-utility",
      "description": "Image Utility Nodes"
    },
    {
      "name": "audio",
      "description": "Audio Nodes"
    },
    {
      "name": "embedding",
      "description": "Embedding Nodes"
    },
    {
      "name": "vector-store",
      "description": "Vector Store Nodes"
    }
  ]
}
